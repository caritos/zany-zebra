-- Migration: Create match_sets table for normalized set scores
-- Date: 2025-09-26
-- Description: Creates a separate table for match sets to properly normalize the data structure

-- Create the match_sets table
CREATE TABLE IF NOT EXISTS public.match_sets (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  match_id BIGINT NOT NULL REFERENCES public.match_records(id) ON DELETE CASCADE,
  set_number INTEGER NOT NULL CHECK (set_number >= 1 AND set_number <= 5),

  -- Regular game scores
  team1_games INTEGER NOT NULL CHECK (team1_games >= 0),
  team2_games INTEGER NOT NULL CHECK (team2_games >= 0),

  -- Tiebreaker scores (NULL if no tiebreaker was played)
  team1_tiebreak_points INTEGER CHECK (team1_tiebreak_points IS NULL OR team1_tiebreak_points >= 0),
  team2_tiebreak_points INTEGER CHECK (team2_tiebreak_points IS NULL OR team2_tiebreak_points >= 0),

  -- Set winner (1 or 2)
  winner INTEGER NOT NULL CHECK (winner IN (1, 2)),

  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),

  -- Ensure unique set numbers per match
  UNIQUE(match_id, set_number),

  -- Validate tiebreaker logic
  CHECK (
    -- Both tiebreak scores must be either NULL or NOT NULL together
    (team1_tiebreak_points IS NULL AND team2_tiebreak_points IS NULL) OR
    (team1_tiebreak_points IS NOT NULL AND team2_tiebreak_points IS NOT NULL)
  ),

  -- Validate set winner based on games
  CHECK (
    -- Regular set win (6-4, 6-3, etc.)
    (team1_games >= 6 AND team1_games > team2_games AND winner = 1) OR
    (team2_games >= 6 AND team2_games > team1_games AND winner = 2) OR
    -- Tiebreaker set (7-6)
    (team1_games = 7 AND team2_games = 6 AND winner = 1 AND team1_tiebreak_points IS NOT NULL) OR
    (team2_games = 7 AND team1_games = 6 AND winner = 2 AND team2_tiebreak_points IS NOT NULL) OR
    -- Golden set (6-0)
    (team1_games = 6 AND team2_games = 0 AND winner = 1) OR
    (team2_games = 6 AND team1_games = 0 AND winner = 2)
  ),

  -- Validate tiebreaker winner
  CHECK (
    (team1_tiebreak_points IS NULL) OR
    (team1_games = 7 AND team2_games = 6 AND team1_tiebreak_points >= 7 AND team1_tiebreak_points > team2_tiebreak_points) OR
    (team2_games = 7 AND team1_games = 6 AND team2_tiebreak_points >= 7 AND team2_tiebreak_points > team1_tiebreak_points)
  )
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_match_sets_match_id ON public.match_sets(match_id);
CREATE INDEX IF NOT EXISTS idx_match_sets_match_set ON public.match_sets(match_id, set_number);

-- Enable RLS
ALTER TABLE public.match_sets ENABLE ROW LEVEL SECURITY;

-- RLS Policies for match_sets
-- Inherit permissions from match_records
CREATE POLICY "Users can view sets for matches they can view"
  ON public.match_sets FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.match_records
      WHERE match_records.id = match_sets.match_id
      AND match_records.club_id IN (
        SELECT club_id FROM public.club_users
        WHERE user_id = auth.uid()
      )
    )
  );

CREATE POLICY "Users can insert sets for matches they recorded"
  ON public.match_sets FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.match_records
      WHERE match_records.id = match_sets.match_id
      AND match_records.recorded_by = auth.uid()
    )
  );

CREATE POLICY "Users can update sets for matches they recorded"
  ON public.match_sets FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM public.match_records
      WHERE match_records.id = match_sets.match_id
      AND match_records.recorded_by = auth.uid()
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.match_records
      WHERE match_records.id = match_sets.match_id
      AND match_records.recorded_by = auth.uid()
    )
  );

CREATE POLICY "Users can delete sets for matches they recorded"
  ON public.match_sets FOR DELETE
  USING (
    EXISTS (
      SELECT 1 FROM public.match_records
      WHERE match_records.id = match_sets.match_id
      AND match_records.recorded_by = auth.uid()
    )
  );

-- Function to migrate existing JSON game_scores to the new structure
CREATE OR REPLACE FUNCTION migrate_game_scores_to_sets()
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  match_record RECORD;
  set_data JSONB;
  set_num INTEGER;
  team1_g INTEGER;
  team2_g INTEGER;
  team1_tb INTEGER;
  team2_tb INTEGER;
  set_winner INTEGER;
  array_element JSONB;
BEGIN
  -- First, delete existing migrated sets to avoid duplicates
  DELETE FROM public.match_sets;

  -- Loop through all matches with game_scores
  FOR match_record IN
    SELECT id, game_scores, winner
    FROM public.match_records
    WHERE game_scores IS NOT NULL
  LOOP
    BEGIN
      RAISE NOTICE 'Processing match % with game_scores: %', match_record.id, match_record.game_scores;

      -- Try to parse as new format {"sets": [...]}
      IF match_record.game_scores ? 'sets' THEN
        RAISE NOTICE 'Found sets format';
        FOR set_num IN 1..jsonb_array_length(match_record.game_scores->'sets')
        LOOP
          set_data := (match_record.game_scores->'sets')->(set_num - 1);
          team1_g := COALESCE((set_data->>'team1_games')::INTEGER, 0);
          team2_g := COALESCE((set_data->>'team2_games')::INTEGER, 0);

          -- Check for tiebreaker
          IF set_data ? 'tie_breaker' AND set_data->'tie_breaker' IS NOT NULL THEN
            team1_tb := (set_data->'tie_breaker'->>'team1_points')::INTEGER;
            team2_tb := (set_data->'tie_breaker'->>'team2_points')::INTEGER;
          ELSE
            team1_tb := NULL;
            team2_tb := NULL;
          END IF;

          -- Determine winner
          IF team1_g > team2_g THEN
            set_winner := 1;
          ELSE
            set_winner := 2;
          END IF;

          RAISE NOTICE 'Inserting set %: %-%% (winner: %)', set_num, team1_g, team2_g, set_winner;

          -- Insert the set
          INSERT INTO public.match_sets (
            match_id, set_number, team1_games, team2_games,
            team1_tiebreak_points, team2_tiebreak_points, winner
          ) VALUES (
            match_record.id, set_num, team1_g, team2_g,
            team1_tb, team2_tb, set_winner
          );
        END LOOP;

      -- Try to parse as simple array format [[6,4], [7,6]]
      ELSIF jsonb_typeof(match_record.game_scores) = 'array' THEN
        RAISE NOTICE 'Found simple array format with % elements', jsonb_array_length(match_record.game_scores);
        FOR set_num IN 0..(jsonb_array_length(match_record.game_scores) - 1)
        LOOP
          array_element := match_record.game_scores->set_num;
          RAISE NOTICE 'Processing array element %: %', set_num, array_element;

          IF jsonb_typeof(array_element) = 'array' AND jsonb_array_length(array_element) = 2 THEN
            team1_g := (array_element->>0)::INTEGER;
            team2_g := (array_element->>1)::INTEGER;

            -- Check if it's a tiebreak set (7-6 or 6-7)
            IF (team1_g = 7 AND team2_g = 6) OR (team1_g = 6 AND team2_g = 7) THEN
              team1_tb := NULL;
              team2_tb := NULL;
            ELSE
              team1_tb := NULL;
              team2_tb := NULL;
            END IF;

            -- Determine winner
            IF team1_g > team2_g THEN
              set_winner := 1;
            ELSE
              set_winner := 2;
            END IF;

            RAISE NOTICE 'Inserting set %: %-%% (winner: %)', set_num + 1, team1_g, team2_g, set_winner;

            -- Insert the set
            INSERT INTO public.match_sets (
              match_id, set_number, team1_games, team2_games,
              team1_tiebreak_points, team2_tiebreak_points, winner
            ) VALUES (
              match_record.id, set_num + 1, team1_g, team2_g,
              team1_tb, team2_tb, set_winner
            );
          END IF;
        END LOOP;
      ELSE
        RAISE NOTICE 'Unknown game_scores format for match %', match_record.id;
      END IF;

    EXCEPTION
      WHEN OTHERS THEN
        -- Log error and continue with next match
        RAISE NOTICE 'Failed to migrate match %: %', match_record.id, SQLERRM;
    END;
  END LOOP;

  -- For matches without game_scores, create a basic set based on the winner
  FOR match_record IN
    SELECT id, winner
    FROM public.match_records
    WHERE game_scores IS NULL
    AND NOT EXISTS (
      SELECT 1 FROM public.match_sets WHERE match_id = match_records.id
    )
  LOOP
    -- Create a single placeholder set
    INSERT INTO public.match_sets (
      match_id, set_number, team1_games, team2_games,
      team1_tiebreak_points, team2_tiebreak_points, winner
    ) VALUES (
      match_record.id, 1,
      CASE WHEN match_record.winner = 1 THEN 6 ELSE 4 END, -- Team 1 games
      CASE WHEN match_record.winner = 2 THEN 6 ELSE 4 END, -- Team 2 games
      NULL, NULL, match_record.winner
    ) ON CONFLICT (match_id, set_number) DO NOTHING;
  END LOOP;
END;
$$;

-- Run the migration
SELECT migrate_game_scores_to_sets();

-- Create a view for easy querying of matches with their sets
CREATE OR REPLACE VIEW match_with_sets AS
SELECT
  mr.*,
  COALESCE(
    json_agg(
      json_build_object(
        'set_number', ms.set_number,
        'team1_games', ms.team1_games,
        'team2_games', ms.team2_games,
        'team1_tiebreak', ms.team1_tiebreak_points,
        'team2_tiebreak', ms.team2_tiebreak_points,
        'winner', ms.winner
      ) ORDER BY ms.set_number
    ) FILTER (WHERE ms.id IS NOT NULL),
    '[]'::json
  ) AS sets
FROM public.match_records mr
LEFT JOIN public.match_sets ms ON ms.match_id = mr.id
GROUP BY mr.id;

-- Grant access to the view
GRANT SELECT ON match_with_sets TO authenticated;

-- Add comment for documentation
COMMENT ON TABLE public.match_sets IS 'Normalized storage for individual set scores within a match, including tiebreaker details';
COMMENT ON COLUMN public.match_sets.team1_tiebreak_points IS 'Tiebreaker points for team 1 (NULL if no tiebreaker played)';
COMMENT ON COLUMN public.match_sets.team2_tiebreak_points IS 'Tiebreaker points for team 2 (NULL if no tiebreaker played)';