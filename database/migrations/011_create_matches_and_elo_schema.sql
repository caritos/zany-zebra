-- Migration: Create matches and ELO rating schema
-- Date: 2025-09-24
-- Description: Adds tables for recording tennis matches and tracking ELO ratings

-- Create user_ratings table to track ELO ratings per club
CREATE TABLE IF NOT EXISTS public.user_ratings (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  club_id BIGINT NOT NULL REFERENCES public.clubs(id) ON DELETE CASCADE,
  elo_rating INTEGER DEFAULT 1200, -- Starting ELO rating
  matches_played INTEGER DEFAULT 0,
  matches_won INTEGER DEFAULT 0,
  matches_lost INTEGER DEFAULT 0,
  last_match_at TIMESTAMPTZ,
  peak_rating INTEGER DEFAULT 1200,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  -- Each user has one rating per club
  UNIQUE(user_id, club_id)
);

-- Create matches table to record match results
CREATE TABLE IF NOT EXISTS public.matches (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  club_id BIGINT NOT NULL REFERENCES public.clubs(id) ON DELETE CASCADE,

  -- Players
  player1_id UUID NOT NULL REFERENCES auth.users(id),
  player2_id UUID NOT NULL REFERENCES auth.users(id),

  -- Scores (using tennis scoring: sets and games)
  player1_sets INTEGER NOT NULL CHECK (player1_sets >= 0),
  player2_sets INTEGER NOT NULL CHECK (player2_sets >= 0),

  -- Optional: detailed game scores per set (stored as JSON array)
  -- Example: [[6,4], [7,5]] means player1 won 6-4, 7-5
  game_scores JSONB,

  -- Winner
  winner_id UUID NOT NULL REFERENCES auth.users(id),

  -- ELO changes
  player1_elo_before INTEGER NOT NULL,
  player2_elo_before INTEGER NOT NULL,
  player1_elo_after INTEGER NOT NULL,
  player2_elo_after INTEGER NOT NULL,
  elo_change INTEGER NOT NULL, -- Absolute value of ELO change

  -- Match metadata
  match_date TIMESTAMPTZ DEFAULT NOW(),
  recorded_by UUID NOT NULL REFERENCES auth.users(id), -- Who recorded the match
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),

  -- Ensure players are different
  CHECK (player1_id != player2_id),
  -- Ensure winner is one of the players
  CHECK (winner_id IN (player1_id, player2_id)),
  -- Ensure there's a clear winner by sets
  CHECK (
    (player1_sets > player2_sets AND winner_id = player1_id) OR
    (player2_sets > player1_sets AND winner_id = player2_id)
  )
);

-- Add indexes for performance
CREATE INDEX IF NOT EXISTS idx_user_ratings_user_club ON public.user_ratings(user_id, club_id);
CREATE INDEX IF NOT EXISTS idx_user_ratings_club_elo ON public.user_ratings(club_id, elo_rating DESC);
CREATE INDEX IF NOT EXISTS idx_matches_club_date ON public.matches(club_id, match_date DESC);
CREATE INDEX IF NOT EXISTS idx_matches_player1 ON public.matches(player1_id);
CREATE INDEX IF NOT EXISTS idx_matches_player2 ON public.matches(player2_id);

-- Add trigger for updated_at
CREATE TRIGGER update_user_ratings_updated_at
  BEFORE UPDATE ON public.user_ratings
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- RLS Policies for user_ratings
ALTER TABLE public.user_ratings ENABLE ROW LEVEL SECURITY;

-- Users can view ratings in their clubs
CREATE POLICY "Users can view ratings in their clubs"
  ON public.user_ratings FOR SELECT
  USING (
    club_id IN (
      SELECT club_id FROM public.club_users
      WHERE user_id = auth.uid()
    )
  );

-- System can update ratings (will use SECURITY DEFINER functions)
CREATE POLICY "System can manage ratings"
  ON public.user_ratings FOR ALL
  USING (true)
  WITH CHECK (true);

-- RLS Policies for matches
ALTER TABLE public.matches ENABLE ROW LEVEL SECURITY;

-- Users can view matches in their clubs
CREATE POLICY "Users can view matches in their clubs"
  ON public.matches FOR SELECT
  USING (
    club_id IN (
      SELECT club_id FROM public.club_users
      WHERE user_id = auth.uid()
    )
  );

-- Users can record matches in their clubs
CREATE POLICY "Club members can record matches"
  ON public.matches FOR INSERT
  WITH CHECK (
    club_id IN (
      SELECT club_id FROM public.club_users
      WHERE user_id = auth.uid()
    )
    AND recorded_by = auth.uid()
  );

-- Function to initialize user rating when they join a club
CREATE OR REPLACE FUNCTION initialize_user_rating()
RETURNS TRIGGER AS $$
BEGIN
  -- Create a rating entry for the new club member
  INSERT INTO public.user_ratings (user_id, club_id)
  VALUES (NEW.user_id, NEW.club_id)
  ON CONFLICT (user_id, club_id) DO NOTHING;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create rating when user joins club
CREATE TRIGGER create_rating_on_club_join
  AFTER INSERT ON public.club_users
  FOR EACH ROW
  EXECUTE FUNCTION initialize_user_rating();

-- Initialize ratings for existing club members
INSERT INTO public.user_ratings (user_id, club_id)
SELECT DISTINCT cu.user_id, cu.club_id
FROM public.club_users cu
ON CONFLICT (user_id, club_id) DO NOTHING;