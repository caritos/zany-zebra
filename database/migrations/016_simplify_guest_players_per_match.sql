-- Migration: Simplify guest players for per-match claiming
-- Date: 2025-09-25
-- Description: Store guest player names directly in match records for individual claiming

-- Drop the existing complex structure
DROP TABLE IF EXISTS public.match_records CASCADE;
DROP TABLE IF EXISTS public.guest_players CASCADE;

-- Create simplified match_records table with guest names stored directly
CREATE TABLE IF NOT EXISTS public.match_records (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  club_id BIGINT NOT NULL REFERENCES public.clubs(id) ON DELETE CASCADE,

  -- Player 1 (can be registered user or guest name)
  player1_user_id UUID REFERENCES auth.users(id),
  player1_guest_name TEXT,

  -- Player 2 (can be registered user or guest name)
  player2_user_id UUID REFERENCES auth.users(id),
  player2_guest_name TEXT,

  -- Scores
  player1_sets INTEGER NOT NULL CHECK (player1_sets >= 0),
  player2_sets INTEGER NOT NULL CHECK (player2_sets >= 0),

  -- Detailed scores per set
  game_scores JSONB,

  -- Winner (1 for player1, 2 for player2)
  winner INTEGER NOT NULL CHECK (winner IN (1, 2)),

  -- Match metadata
  match_type TEXT CHECK (match_type IN ('singles', 'doubles', 'practice')) DEFAULT 'singles',
  match_date TIMESTAMPTZ DEFAULT NOW(),
  duration_minutes INTEGER,
  recorded_by UUID NOT NULL REFERENCES auth.users(id),
  notes TEXT,
  location TEXT,
  court_surface TEXT CHECK (court_surface IN ('hard', 'clay', 'grass', 'indoor', 'other')),
  created_at TIMESTAMPTZ DEFAULT NOW(),

  -- Validation constraints
  CHECK (
    -- Each player must be either a user or have a guest name, not both
    (player1_user_id IS NOT NULL AND player1_guest_name IS NULL) OR
    (player1_user_id IS NULL AND player1_guest_name IS NOT NULL)
  ),
  CHECK (
    (player2_user_id IS NOT NULL AND player2_guest_name IS NULL) OR
    (player2_user_id IS NULL AND player2_guest_name IS NOT NULL)
  ),
  -- Players must be different (prevent same user vs same user)
  CHECK (
    NOT (
      player1_user_id IS NOT NULL AND
      player2_user_id IS NOT NULL AND
      player1_user_id = player2_user_id
    )
  ),
  -- Winner must have won more sets
  CHECK (
    (player1_sets > player2_sets AND winner = 1) OR
    (player2_sets > player1_sets AND winner = 2)
  )
);

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_match_records_club_date ON public.match_records(club_id, match_date DESC);
CREATE INDEX IF NOT EXISTS idx_match_records_player1_user ON public.match_records(player1_user_id) WHERE player1_user_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_match_records_player2_user ON public.match_records(player2_user_id) WHERE player2_user_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_match_records_guest_names ON public.match_records(player1_guest_name, player2_guest_name);

-- RLS Policies for match_records
ALTER TABLE public.match_records ENABLE ROW LEVEL SECURITY;

-- Club members can view matches in their clubs
CREATE POLICY "Club members can view matches"
  ON public.match_records FOR SELECT
  USING (
    club_id IN (
      SELECT club_id FROM public.club_users
      WHERE user_id = auth.uid()
    )
  );

-- Club members can record matches
CREATE POLICY "Club members can record matches"
  ON public.match_records FOR INSERT
  WITH CHECK (
    recorded_by = auth.uid() AND
    club_id IN (
      SELECT club_id FROM public.club_users
      WHERE user_id = auth.uid()
    )
  );

-- Users can update matches they recorded
CREATE POLICY "Users can update their recorded matches"
  ON public.match_records FOR UPDATE
  USING (recorded_by = auth.uid())
  WITH CHECK (recorded_by = auth.uid());

-- Users can delete matches they recorded
CREATE POLICY "Users can delete their recorded matches"
  ON public.match_records FOR DELETE
  USING (recorded_by = auth.uid());

-- Function to claim a specific guest player spot in a specific match
CREATE OR REPLACE FUNCTION claim_guest_match_spot(
  p_match_id BIGINT,
  p_player_number INTEGER -- 1 or 2
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_user_id UUID;
  v_club_id BIGINT;
  v_match RECORD;
BEGIN
  -- Get the current user
  v_user_id := auth.uid();

  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'User not authenticated';
  END IF;

  -- Get the match details
  SELECT * INTO v_match
  FROM public.match_records
  WHERE id = p_match_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Match not found';
  END IF;

  v_club_id := v_match.club_id;

  -- Verify user is a member of the club
  IF NOT EXISTS (
    SELECT 1 FROM public.club_users
    WHERE user_id = v_user_id AND club_id = v_club_id
  ) THEN
    RAISE EXCEPTION 'User must be a member of the club to claim this match spot';
  END IF;

  -- Verify the user is not already part of this match
  IF v_match.player1_user_id = v_user_id OR v_match.player2_user_id = v_user_id THEN
    RAISE EXCEPTION 'User is already part of this match';
  END IF;

  -- Claim the appropriate player spot
  IF p_player_number = 1 THEN
    -- Verify player1 is a guest
    IF v_match.player1_guest_name IS NULL THEN
      RAISE EXCEPTION 'Player 1 is not a guest player';
    END IF;

    -- Claim player1 spot
    UPDATE public.match_records
    SET player1_user_id = v_user_id,
        player1_guest_name = NULL
    WHERE id = p_match_id;

  ELSIF p_player_number = 2 THEN
    -- Verify player2 is a guest
    IF v_match.player2_guest_name IS NULL THEN
      RAISE EXCEPTION 'Player 2 is not a guest player';
    END IF;

    -- Claim player2 spot
    UPDATE public.match_records
    SET player2_user_id = v_user_id,
        player2_guest_name = NULL
    WHERE id = p_match_id;

  ELSE
    RAISE EXCEPTION 'Invalid player number. Must be 1 or 2';
  END IF;
END;
$$;